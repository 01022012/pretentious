class Pretentious::RspecGenerator < Pretentious::GeneratorBase

  def initialize(options = {})
    @deconstructor = Pretentious::Deconstructor.new
    indentation_count = options[:indentation] || 2
    @output_buffer = ""
    @_indentation = ""
    indentation_count.times do
      @_indentation << " "
    end
  end

  def indentation(level)
    buffer = ""
    level.times do
      buffer << @_indentation
    end
    buffer
  end


  def whitespace(level = 0)
    @output_buffer << "#{indentation(level)}\n"
  end

  def begin_spec(test_class)
    buffer("#This file was automatically generated by the pretentious gem")
    buffer("require 'spec_helper'")
    whitespace
    buffer("RSpec.describe #{test_class.name} do")
    whitespace
  end

  def end_spec
    buffer("end")
  end

  def output
    @output_buffer
  end

  def generate(test_instance, instance_count)
    if (test_instance.is_a? Class)
      #class methods
      class_method_calls = test_instance.method_calls_by_method
      generate_specs("#{test_instance.test_class.name}::", test_instance.test_class.name,
                     class_method_calls, test_instance.let_variables)
    else
      buffer("context 'Scenario #{instance_count}' do",1)

      buffer("before do",2)
      buffer_inline(test_instance._deconstruct_to_ruby('@fixture', 3 * @_indentation.length))
      buffer("end",2)
      whitespace

      method_calls = test_instance.method_calls_by_method

      generate_specs("#{test_instance.test_class.name}#","@fixture",method_calls, test_instance.let_variables)

      buffer('end',1)
      whitespace
    end

  end

  private



  def proc_function_generator(block, method)
    "func_#{method.to_s}(#{Pretentious::Deconstructor.block_params_generator(block)})"
  end

  def get_block_source(block,let_variables, declared,indentation)
    #output = ''
    #output << "{ #{Pretentious::Deconstructor.block_params_generator(block)}\n"
    #output << Pretentious::Deconstructor.proc_body(block, let_variables, declared,indentation)
    #output << "#{indentation}}"
    #output
    " &#{Pretentious::Deconstructor.pick_name(let_variables, block.target_proc.object_id, declared)}"
  end

  def generate_expectation(fixture, method, let_variables, declarations, params, block, result)
    block_source = if !block.nil? && block.is_a?(Pretentious::RecordedProc)
                      get_block_source(block, let_variables, declarations, @_indentation * 3)
                   else
                     ''
    end

    statement = if params.size > 0
      "#{fixture}.#{method.to_s}(#{params_generator(params, let_variables, declarations)})#{block_source}"
    else
      stmt = []
      stmt << "#{fixture}.#{method.to_s}"
      stmt << "#{block_source}" unless block_source.empty?
      stmt.join(' ')
    end

    if (result.kind_of? Exception)
      buffer("expect { #{statement} }.to #{pick_matcher(result)}",3)
    else
      buffer("expect( #{statement} ).to #{pick_matcher(result)}",3)
    end
  end

  def generate_specs(context_prefix, fixture, method_calls, let_variables)
    buffer("it 'should pass current expectations' do",2)
    declaration = {}
    #collect all params
    params_collection = []
    mocks_collection = {}
    method_call_collection = []

    method_calls.each_key do |k|
      info_blocks_arr = method_calls[k]
      info_blocks_arr.each do |block|
        method_call_collection << block
        params_collection = params_collection | block[:params]
        if (!Pretentious::Deconstructor.is_primitive?(block[:result]) && !block[:result].kind_of?(Exception))
          params_collection << block[:result]
        end

        unless (block[:block].nil?)
          params_collection << block[:block]
        end

        block[:context][:calls].each do |mock_block|
          k = "#{mock_block[:class]}_#{mock_block[:method]}"

          if mocks_collection[k].nil?
            mocks_collection[k] = []
          end

          mocks_collection[k] << mock_block
          params_collection << mock_block[:result]

        end if block[:context]


      end

    end

    if (params_collection.size > 0)
      buffer(declare_dependencies(params_collection, let_variables, 3 * @_indentation.length, declaration, []))
    end

    if (mocks_collection.keys.size > 0)
      buffer(generate_rspec_stub(mocks_collection, let_variables, 3 * @_indentation.length, declaration))
    end

    method_calls.each_key do |k|
      info_blocks_arr = method_calls[k]

      info_blocks_arr.each do |block|

        params_desc_str =  if block[:params].size > 0
                             "when passed #{desc_params(block)}"
                           else
                             ""
                           end

        buffer("# #{context_prefix}#{k} #{params_desc_str} should return #{block[:result]}", 3)
        generate_expectation(fixture, k, let_variables, declaration, block[:params], block[:block], block[:result])

        whitespace
      end


    end
    buffer("end",2)
  end

  def generate_rspec_stub(mocks_collection, let_variables, indentation_level , declaration)
    indentation = ""

    indentation_level.times {
      indentation << ' '
    }
    str = ""
    mocks_collection.each do |k,values|
      vals = values.collect { |v| Pretentious::value_ize(v[:result], let_variables, declaration) }

      #check if all vals are the same and just use one
      vals = [vals[0]] if vals.uniq.size == 1

      str << "#{indentation}allow_any_instance_of(#{values[0][:class].to_s}).to receive(:#{values[0][:method].to_s}).and_return(#{vals.join(', ')})\n"
    end
    str
  end

  #def generate_specs(context_prefix, fixture, method_calls, let_variables)
  #  method_calls.each_key do |k|
  #    info_blocks_arr = method_calls[k]
  #
  #    buffer("context \"#{context_prefix}#{k}\" do", 1)
  #
  #    whitespace
  #    info_blocks_arr.each do |block|
  #      buffer("it '#{desc_params(block)} returns #{block[:result]}' do",2)
  #      whitespace
  #      if block[:params].size > 0
  #        buffer(declare_dependencies(block[:params], let_variables, 3))
  #        buffer("expect(#{fixture}.#{k.to_s}(#{params_generator(block[:params], let_variables)})).to #{pick_matcher(block[:result])}",3)
  #      else
  #        buffer("expect(#{fixture}.#{k.to_s}).to #{pick_matcher(block[:result])}",3)
  #      end
  #      whitespace
  #      buffer("end",2)
  #      whitespace
  #    end
  #
  #    buffer("end", 1)
  #    whitespace
  #  end
  #end

  def pick_matcher(result)
    if result.is_a? TrueClass
     'be true'
    elsif result.is_a? FalseClass
      'be false'
    elsif result.nil?
      'be_nil'
    elsif result.kind_of? Exception
      'raise_error'
    else
      "eq(#{Pretentious::value_ize(result, nil, nil)})"
    end
  end



  def desc_params(block)
    params = []
    args = block[:params]
    names = block[:names]
    n = 0
    #puts args.inspect
    return "" if args.nil?

    args.each do |arg|
      param_name = names[n][1].to_s
      arg_value = (arg.is_a? String) ? "#{arg.dump}" : "#{arg.to_s}"
      if (param_name.empty?)
        params << "#{arg_value}"
      else
        params << "#{param_name} = #{arg_value}"
      end

      n+=1
    end
    params.join(" ,")
  end

  def declare_dependencies(args, variable_map, level, declarations, method_call_collection)
    deconstructor = Pretentious::Deconstructor.new

    args = remove_primitives(args, variable_map)
    deconstructor.deconstruct_to_ruby(level, variable_map, declarations, method_call_collection, *args)
  end

  def remove_primitives(args, let_lookup)
    args.select { |a| let_lookup.include?(a.object_id) || !Pretentious::Deconstructor.is_primitive?(a) }
  end

  def params_generator(args, let_variables, declared_names)
    params = []
    args.each do |arg|
      if (!let_variables.nil? && let_variables[arg.object_id])
        params <<  Pretentious::Deconstructor.pick_name(let_variables, arg.object_id, declared_names)
      else
        params << Pretentious::value_ize(arg, let_variables, declared_names)
      end

    end
    params.join(", ")
  end

  def self.location(output_folder)
    output_folder.nil? ? "spec" : File.join(output_folder, "spec" )
  end

  def self.naming(output_folder, klass)
    klass_name_parts = klass.name.split('::')
    last_part = klass_name_parts.pop
    File.join(output_folder, "#{DdtUtils.to_underscore(last_part)}_spec.rb")
  end

  def self.helper(output_folder)
    filename = File.join(output_folder,"spec_helper.rb")
    unless File.exists?(filename)
      File.open(filename, 'w') {
          |f| f.write("#Place your requires here")
      }
      puts "#{filename}"
    end
  end
end